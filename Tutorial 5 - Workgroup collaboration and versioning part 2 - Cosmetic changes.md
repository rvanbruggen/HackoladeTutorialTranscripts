
# Tutorial 5 - Workgroup collaboration and versioning part 30 - Cosmetic changes

[Tutorial 5 - Workgroup collaboration and versioning part 30 - Cosmetic changes](https://community.hackolade.com/slides/slide/workgroup-scenario-1-cosmetic-changes-35?fullscreen=1)

## Transcript of the video

so in scenario one what we'll be doing here is we're going to take a look at these two clones right and we're going to grab the data model from the main branch and in Clone one will make a cosmetic change right and you know we'll continue to work on that uh clone right but we will also switch to you know after we've made that cosmetic change in Clone one we're actually going to open up the version in Clone 2 make a different cosmetic change there and also push that back to the main to the remote therefore you're going to have a scenario where the Cosmetic change that we had made in Clone 1 which has not been pushed back to the remote now first needs to pull before it can actually push the original cosmetic change back into the remote right so you will see you know there will be a push pull before you push and as a consequence you know there's going to be some small conflicting changes to the data model that are going to have to be automatically resolved and a similar thing can happen in the Clone 2 right you can make some changes there and you know it can come back into the main by pushing it back right so that's the scenario it's a very simple scenario and what we want to illustrate here is that there are changes that can happen in parallel edits of the same data model that actually lead to some conflict but that Accolade is going to be automatically resolving let's take a look at this so here I am in the hankel aid studio right and I only have one file inside this clone one right and that is the mongodb data model that I have over here I have opted to only show the models in this list here but actually you know all the other files are accessible here as well what I'm going to do is I'm going to open this model from the Clone one and you will see here there is a sessions entity over here and it comments entity over there and what I'll do is I'll actually you know put this one over here as simple as that right and save that to to my clone one that means that in Clone one I can now commit this right committing cosmetic change but not pushing it right so committing it right now I'll go back to the model and I'll actually close it right so here you go right so the the model the change has been committed but it has not been pushed and now I'll switch to clone two and I'll open up the model from over there right from the other clone of the same repo that you know I'm using to simulate that people are collaborating on that repo right so now I'm going to open it over there and as you can tell right the session entity is over here and the commons entity is over there right so now I'll actually move this one to the left over there right which is different from what I had before right that would be in Clone one I moved everything to the right in Clone two I'm moving everything to the left right so if I save this now then again I can go back to my GitHub repo and see that there are some changes that I can commit specifically I've moved it to the left right so committing and pushing from clone 2. to the remote right so committing and pushing that right so that has now happened so that means that clone two and the remote are now 100 in sync if I go back to clone one I will see something very different right not only is my local commit still waiting to be pushed but all of a sudden I actually have an indication here that says well you know what before you can push you first have to pull right so let's do that we'll pull first and as you can see here there was a little dialogue there that said well actually there was a conflict right so now I uh Accolade has been smart enough to resolve that conflict right the conflict automatically and if I now commit and push that right and I will see in the history here that actually Accolade automatically resolve this right and that now if I go back and I open the file from the Clone one and I will see that automatically this is now all on the left in Clone one right if I switch back to clone two right and uh now clone 2 will actually have an out of date version in its uh clone so it first needs to pull right and once it does that you will see that the file that I have over here in Clone 2 also has both entities on the left right if I now change this back you know I put it over here for example and save it right then obviously uh I'm going to remove commit this as well moving one entity to the right right committing and pushing this right so now the file that I have here is you know having one entity on every side here and if I go back to the other clone clone one it will say well you actually need to pull right because something has happened since you last uh edited your copy and now I will see that um there are again one entity on the left and one entity on the right right so that's how that happens and you can see that hacklight is really helping us to automatically resolve those conflicts great that's the end of scenario one and now we can proceed to the next scenario