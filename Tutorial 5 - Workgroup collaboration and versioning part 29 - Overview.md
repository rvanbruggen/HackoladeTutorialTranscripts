
# Tutorial 5 - Workgroup collaboration and versioning part 29 - Overview

[Tutorial 5 - Workgroup collaboration and versioning part 29 - Overview](https://community.hackolade.com/slides/slide/workgroup-collaboration-overview-34?fullscreen=1)

## Transcript of the video

hello everyone and welcome to another episode of our Hackley tutorial today we're going to be talking about something that is quite important and quite an undertaking actually because it's going to take us a little bit of a little bit of time to get through everything we're going to be talking about how you can use Accolade in the Accolade studio for versioning and collaborating on your data models this is a really important part of our story we call it one of our pillars because we believe that it's going to be essential for us to tie in to the modern ways of developing software if we want to keep the data modeling industry in general as relevant as it ever has been right we all know that you know in agile software development we have this infinity loop right where wherever you are there's always something happening to the code base to the software project that we're working on we're always planning coding building testing releasing deploying operating and monitoring what is happening to our software it's a continuous process that you know for as long as the business application is relevant and adding value to the processes this is going to continue forever now what hackerlaid has been advocating is that this should also apply to the data models that are used in this life cycle right so whenever you have this infinity loop happening for your software at the same time you should be specifying your data model designing it you know generating the schemas for it cataloging it integrating and migrating it publishing it using it evaluating it and starting all over again right so the devops infinity loop should also be accompanied by a data modeling life cycle that is also an infinity loop we think this is really important right we really think that data modeling in an agile and devops context should still be happening for some time people have been saying that you know with all these agile Technologies with all these nosql Technologies you know the data is the model we don't really need to be thinking through our data models as much well we we disagree we think that this is still not an optional thing to do it should still be a mandatory thing to do and it will greatly help software quality the software costs the delivery time frame and everything that goes with a good quality software delivery in an agile Enterprise we call this metadata as code we believe that if we treat our metadata just the way we treat our code with the same care with the same agility with the same speed tune it in to the business life cycle that we are trying to accommodate that is actually going to prove and and deliver the relevance that we need for the data models in everyday practice so we want to treat the metadata as code and in the Accolade Studio we have built a number of tools that allow you to do this really really easily and all of these mechanisms are built on git right git is something that many technical people will probably already be familiar with many less technical people may not have ever touched it and may even be a little bit afraid of it what is good well git is something that was originally developed by the store valves for the Linux software development Community right so it's a Version Control System but it was geared to that Community which means that it was inherently distributed right so git is a version control system that is not relying on you know centralized control and centralized copies of the latest software version no on the contrary it's actually depending on a distributed version of that software so that you know all of the different contributors to the Linux ecosystem could work in parallel and could you know help each other and collaborate without too much Reliance on that centralized system so this is very different very different from traditional Central Version Control Systems made for agile teams and conspicuously and and consciously not dependent on so-called locking systems right so in a centralized Version Control System people always dependent on the fact that you know someone would be locking the version of the code base that people will be working on while you know other people just basically had to wait right so that mechanism obviously is a kind of like a shotgun approach you know okay we lock everything so now it's probably going to be safe right git is much smarter a distributed version control system is much smarter and is much more granularly organized so that you know people can constantly work on their part of the code base without actually impacting someone else that means that there's a completely different way of working accompanied by a completely different vocabulary right so we will be talking about push and pull and pull requests and these are very much new Concepts for many different people and many data modelers specifically originally git was also something that was actually based on a command line interface only and to be honest that was kind of daunting for many people not just data modeler so in Accolade Studio we're going to try and make this easier to use so that everyone can leverage git right and that the decentralized distributed version control system that it offers will actually contribute to a much more successful way of doing data modeling what we mean with that is that you know first of all thanks to Accolade Studios json-based file storage you know it's actually really easy for us to use git for the task of managing versions and collaborating on these Json documents that are underpinning our data models right on top of that you know the entire approach right where um people are constantly working together and constantly working in parallel on their part of the task is very much in tune with our love for agile software development domain driven design and the Wayne driven data modeling and nosql data storage formats we think that this really plays well with our vision we want to reconcile business nit through a shared understanding of the meaning and the context of data and we're going to do that by making it easy for everyone to interact with Git so that business can use the same tool as it so that business nit can leverage the same single source of Truth what does that mean well it basically means that every time you're working on a data model and that you're generating schema or that you're working on application code all of these resources all of these artifacts are going to be uploaded to the git repository that is shared by everyone the wonderful thing about git also not just the fact that it's a decentralized distributed version control system is that it's so well integrated with lots and lots of very powerful automation tools everyone's been talking about developer operations devops right well devops one of the key things that they do is that they operate with pipelines they make sure that every time something needs to get deployed into production this is not someone manually pushing a few buttons or typing a few commands no there's an entire pipeline that automates this and therefore if our modeling artifacts are also present in the same git repos that means that these pipelines can also leverage those models right they can also integrate things like automatic documentation generation right all of that is now all of a sudden possible thanks to the fact that the models actually reside in git so what are you going to do well all of us are going to be working in our local repos right the Clones of the uh git repository we are going to store our models in these repos and you know time and time again we're going to be uploading those models to decentralized remote copy of the git report the tree so that all of a sudden we can integrate this super easily through potentially our command line interface Accolade command line interface to for example generate schemas right ddl files OS files Json schema files Avro whatever it might be right it's going to be automatically generated through the command line interface and of course also stored inside Wicked repo so that we can then send this to all kinds of consumers for example the documentation that we generate can be automatically distributed to whoever wants to read the entire orchestration the entire orchestration that we know from our devops code generation processes is now also going to be underpinning our metadata pipelines right so that the technicals data structures and the business facing data dictionaries will always be in sync with the latest and greatest version of what we are delivering to our business users so that means that git is going to be the basis for all collaboration all Version Control all change tracking tracking and all reviews that are currently being performed on our data models now in the rest of this tutorial we are going to be showing you in detail how this can work right and we're going to be doing this using four different scenarios right because there's quite a few ways that you can organize this and so now what I'm going to do is I'm going to tackle each of these scenarios you know from very simple to quite complex in a sequence and then I'll come back to you and we can wrap up this tutorial all right so let's get going so how are we going to do this well what I've done is I've created a specific GitHub repo that will allow you to quickly understand how this type of environment might work however there's a couple of things that are a little bit specific about it and I'll try to explain those but the repo is this one over here it's called Accolade git test repo right there's a readme here and actually in readme we're going to be following um some of the instructions that you find here with all the different scenarios we're going to be walking through that as we go along here the important thing that you should realize is that in this repo we actually are going to store our data models but we're going to store them in two separate clones on my local machine and this is important right so we have the remote right which is the centralized storage of our modeling information and potentially also our code and what I have created is two separate clones clone one and clone two all my local machine to simulate how we could collaborate with with one another right so right now these clones are going to be used by the same user right this uh in both cases is going to be me right but um what you will see is that it doesn't really matter which user is actually using those clones it is all about you know what happens in those clones and how the actions that we take inside those clones get reconciled and get merged together inside the centralized remote copy right so let me show you this right so I've got my GitHub test repo right here and inside it I have created two clones clone one and clone two and of course right now they are identical they are exactly the same you've got the same readme file you've got the same basic model in here and you got some illustrations in there right and it's exactly the same because both clones have just been pulled from the remote so that they are identical that process is actually facilitated inside Accolade right in the git interface of Accolade you will see that I have a clone one and clone two repository in which I can also have separate branches right so in every clone I can have a branch and I'm working that branch and then you know push that Branch to the remote so that it can be merged into the main branch right so we've got that here in Accolade as well and we can work with that and now that we've done that we are ready to start actually collaborating and we will start doing that in a series of different scenarios