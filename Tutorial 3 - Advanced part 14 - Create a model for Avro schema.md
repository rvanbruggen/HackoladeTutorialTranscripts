
# Tutorial 3 - Advanced part 14 - Create a model for Avro schema

[Tutorial 3 - Advanced part 14 - Create a model for Avro schema](https://community.hackolade.com/slides/slide/create-a-model-for-avro-schema-56?fullscreen=1)

## Transcript of the video

In today's episode we'll be talking about how you can use the Hackolade studio for visually designing your Avro schemas.

Avro schemas have been around for quite some time. I believe they've been started at about the time when the Hadoop ecosystem was really emerging. It was an open source project that basically provides us with a data serialization framework and data exchange services that are compatible with a wide variety of different Technologies it's often used with things like Kafka Pub/Sub pipelines, or with Data Lake storage capabilities. 

<img width="1104" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/7153351c-3397-4543-afd7-cc14c570fdba">

What's important to realize is that the Avro file format is actually a **row oriented** object container, as opposed to for example **Parquet files** that have a **column oriented file format**. This is important because it might Define the workload where you might be applying this type of Technology. Avro is typically used in more _write intensive_ types of operations whereas Parquet is very often used in more _read intensive_ operations. The nice thing about Avro is that it's actually language independentm it's quite compact and therefore also quite efficient in its usage.

When you develop open Avro schema model using the Accolade toolset you will actually see that it's kind of like a language agnostic contract for how different systems can interoperate. For every schema you will find that there are four types of attributes:
* the **type** you know the specific data type of the Json record that you are including in the model
* the name of the Avro schema that you are defining
* the name space which is the higher level logical indicator of the overall schema, and then of course
* all of the individual Fields the individual data elements that you are including here in the Hackolade Studio

<img width="1108" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/e0f148fb-f66e-4b05-aaa2-7c36b591abde">

As usual you will find both an entity relationship representation of this model and a hierarchical representation.  As you can see in these little graphics Avro uses JSON to define the schema and the data types that you are going to be using, but it's a little bit different from what the JSON schema typically provides.

<img width="1107" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/31672260-55aa-459b-b0d4-5c82a0c28ebb">

Even though the Avro schema is actually defined using a Json format you will see that the container file has a header that contains the schema up plus one or more storage blocks. You can see the composition and the structure of these files in the little overview graphic here on this slide. 

One of the most powerful capabilities of an Avro schema is that it allows for **Schema Evolution**. This is important: you know if you're using uh Avro as a contract between different systems then it's important that you might have different versions of that capability in production at the same time imagine a situation where you have thousands of Publishers, producers of information that are integrating with some kind of integration hub? Well you will never be able to ensure 100% version compatibility between all of these different systems. They will never be on the same version! Having said that you might be able to engineer it in such a way that all of the different versions that are being used are still compatible with one another. Both backward and forward compatibility is a very strong feature of the Avro technology. 
<img width="1107" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/1767be7d-047a-49a5-8946-45956b03070e">
It makes it super interesting for integration Services, as I just explained. Very often these types of schema versions will be published in a **schema registry** and we'll talk more about that in a little bit. Schema Registries is where people can look at these different evolving versions which of course enables the goal of maximizing compatibility, because you're decoupling the life cycle of Publishers and consumers. There are specific guidelines and best practices for this which we will now be covering in this tutorial. 

In the Hackolade Studio you will find a visual design environment for the Avro schema, that allows you to anticipate the evolution of the schema. It allows for message validation, optimizing the message payloads. It allows you to enable compatibility and interoperability and of course it integrates with the Confluent or other Schema Registry.
<img width="1108" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/1335b427-d8b7-46d9-948e-840a95c72d34">
This of course enables and promotes the reuse of the schema, despite the limited official specification and documentation that is out there. So we include support for things like Avro name space references and Confluence schema Registries schema references or Union schemas. 

So it's a graphical Avro schema design tool which you can also use to import existing Avro schemas. Different schema Registries are supported: Confluent schema registry, Azure event hubs schema registry, Pulsar schema registry and other Confluent schema registry API compatible registries can also be added to the Hackolade Studio. We support both forward and reverse engineering of the Avro schema into these registries but we can also work with simpler object storage providers for a completely different use case. 
<img width="1108" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/f6409686-8ef2-4a4b-81d2-536ef794b83f">
We can reverse engineer the Avro files that have been stored in those object storage providers like S3 or ADLS which contain Data Lake files, basically, and then reverse engineer the schema of those files and include them in our Hackolade model. We maintain all of the references, also the recursive references between the elements in the Avro schema, so the outputs then are your ERD, your hierarchical view (I mentioned those two earlier) but also the syntactically correct schema generation for both users that have limited technical knowledge or developers that want to improve their productivity and their quality of their work. 
<img width="1106" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/47ee2461-4cb9-46e8-9d06-d24daae23602">
It's also very useful of course that thanks to our **polyglot data modeling capabilities** you can actually convert to the other target models like open API models or relational databases or nosql databases, and you can convert them into an Avro schema super easily. 

So the integration with the schema registry is through a restful interface right we will show that a little bit later where developers can publish their schemas you can host this yourself or use one of the cloud capabilities and it's you know it's a native capability where you can forward or reverse engineer the schema in the registry. 
<img width="1105" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/6eef858b-e1a2-48f6-a5b3-1a344badf272">
It allows for of these references. Schema references and Union schemas with that. Let's take a look at the short little demo and then we can take it from there all right let's give you guys a little bit of a tour here please do review our website and the documentation. There's going to be some really great information there for sure but also I would like to highlight that we'll be looking at a specific demo environment here that we've set up for the Confluent cloud. 

<img width="1109" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/a8b1e386-2eb2-48da-875a-2f8c5b51c30c">
It's just a online free version of the schema registry. There's a couple of schemas in here but we'll be adding some more to it using our Hackolade toolset. So what we'll do now is we'll create a new Avro schema and in this schema we're going to first create a namespace. So this is customer and now within the namespace I'll add a record customer address and when the within the record I'm going to add a nested structure which is the address and the nested structure is going to look like this I'll add a field here which is a string which has the street it has the house number it has the zip code it has the city and also of course the country.
<img width="1109" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/0c3a6076-9802-4fff-b510-371856613478">
These are the elements that we'll be adding into our Avro schema and obviously when I save this right I'll save it into a particular directory over here overwrite what I already have when I save this. Obviously you will see that I also have all of the hierarchical capabilities right so I see what the structure is like in a hierarchical view.
<img width="1109" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/a301dc4e-23d1-441c-a9c7-bf5a8c59dead">
But I can also say well you know I'd actually like to forward engineer this into either a file format or an entry into the schema registry. So this is the registry right now: I've got a four schemas in there I'd like to add one here right so the Avro schema is valid as you can tell here and I can say okay let's apply this to my Confluent schema registry I have the connectivity set up. Let's connect to it and boom now the script actually added the schema to the registry. So if I refresh it you should see the customer address over here so what I'll do next is I'll actually try to evolve this schema using our Hackolade Studio, and I'll for example add another field here right which is a test field um save this again and do the same thing I would like to forward engineer this to our overall schema registry and I'll already warn you we are going to get an error here right so it's going to say that the schema is being registered because it's incompatible with the schema for the same topic and the compatibility requirements.
<img width="1111" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/ab3da8dc-1a1b-452b-8881-83fd518361b2">

Okay let's go and check this one out then and over here you will now see that there is a specific **compatibility mode** that has been set up which is Backward Compatible so when you change something to the registry and you forward engineer the Avro schema based on our model into the schema registry then of course it's going to check for some compatibility. It has to be Backward Compatible in this case which obviously is not the case because I have created this particular additional field here which is a required field. so what I'll do now is I'll add one of two things I can either go into my schema registry and loosen the compatibility settings and set them to none, of course. 

But you know the smartest thing to do is to actually look at some of Hackolade's Advanced features: which is that foreign schema you know this is the Avro schema page we can actually create something called a union type which is a really great capability that allows you to deal with these incompatibilities in a structured way and allow for both cases to happen. So let's see what we'll do here is we'll go into hackerlade and say well this test field that we have over here is actually not going to be a string but it's actually going to be a null value that is not required and then we'll actually have the possibility for it to be empty or to be a string so let me show you how to do that right so we have two values that are possible here now null or a string right.
<img width="1110" alt="image" src="https://github.com/rvanbruggen/HackoladeTutorialTranscripts/assets/2995654/27615c31-3b1d-4fb8-bf95-ffd7673df699">
So these both of these are now possible.

I'll just save this you see here in the test field it's a multi now and I'll go and forward engineer that to my Avro schema registry and you will see that now the compatibility requirements are met and the new model has been applied successfully.

So let's see here right so now I have two versions of the model I can actually go and look at that compare the versions these are the this is the new version right with the default null where two possibilities are available: null or string. So that's great I just wanted to illustrate how you can use Hackolade's capabilities to the maximum, including some of the advanced Avro data types. 

Obviously some of these model comparisons that we showed in the control schema registry environment you can also do those comparisons in Hackolade but it's always good to have multiple options.

That concludes our little demo and so therefore I am going to return to this particular slide to recommend that you read up on some of this material look at the Hackolade Studio [online documentation](https://hackolade.com/help/index.html), the [blog](https://hackolade.com/blog.html) but also the [books](https://hackolade.com/books.html) that we've created recently there's more coming and of course you are very welcome to follow us on the socials and try the tool for free you can just [download Hackolade Studio](https://hackolade.com/download.html) and get started for free. That wraps up this part of the tutorial I hope this was useful and I wish you a wonderful rest of your day.
