
# Tutorial 1 - Beginner part 3 - Query-driven data modeling based on access patterns

[URL of video: Tutorial 1 - Beginner part 3 - Query-driven data modeling based on access patterns](https://community.hackolade.com/slides/slide/part-3-query-driven-data-modeling-based-on-access-patterns-5?fullscreen=1)

## Unedited transcript of the video

hello everyone and welcome to today's hack late tutorial this is part three of our Hackley tutorial you know we've treated um uh data modeling Concepts and Json in previous episodes which I obviously invite you to go back at and look at um but right now we're going to be focusing on a very specific topic we're going to Dive Right In which is query driven data modeling based on access patterns let's um take a look here right what we're going to be talking about is some of the rules that underpin our data modeling efforts right the rules that we used to know were very clear they were the rules of normalized database systems right so we would use normalization as a technique to decide okay how are we going to structure the data in our system if you look at an order that would be processed by a particular system it would split up all of the information on the order into a number of different tables it would be an order table a customer table or the line table a product table a payment type table and all of these things will be split up and joined together in this one transaction to place an order right so this was the way that we used to do things in relational database Management Systems still being done today the world lives on and it's a very powerful and good way to do it but it was really optimized for a particular purpose which is making sure that we didn't have to duplicate data that data was always stored in one place that has changed changed with the Advent of first of all the internet and the scale that it brought to many of the companies on the internet but also because it drove a number of Innovations in the database landscape one of those Innovations or many of those Innovations are grouped together in what we call nosql databases right and they're not Superior to traditional database Management Systems relational database Management systems but they are very different they use different data models first of all right so nosql databases for example use the document the Json document model that we treated in the previous episode of this tutorial or graph databases use networks right property graphs as a way to store their data you have other storage formats around in the nosql space so the data model is fundamentally different for these new database management systems that also means that there will be different sizing parameters and and different capabilities that are associated with this right I mean some of these um nosql databases are incredibly impressive with when it comes to their horizontal scalability you know they have these massively distributed infinitely distributed architecture that allows them to combine thousands of servers into one coherent database management system one of the ways that they can do that is by also treating transactions in a different way many of those nosql databases talk about their consistency model you know whether or not it's an immediate versus a an eventual consistency model they also talk about Acid versus base you know we remember from our computer science days maybe you know acid transactions Atomic consistent isolated and durable transactions I'm not going to go into that but this is the old way that relational management database Management Systems used to do their transactions well in the new uh way of Performing transactions in nosql database we also we often talk about base which is you know basically available soft State and eventually consistent right so very different and probably appropriate for a range of different use cases right so this is probably one of the key things that came out of this nosql revolution is that you really optimize the database structure for the use case you know this is where polyglot persistence comes from as well but when you have this new architecture when you have this new nosql database back end you also still need to talk about schema design obviously but it requires you to do that in a different way adhering to different rules and parameters some of the rules that we used to have around normalization they just don't apply anymore it's not a bad thing if data gets duplicated in two documents for example it's not necessarily A a big drama right no it also means that sometimes we're going to be aggregating information that belongs together right if we're processing orders then why not aggregate these things together into one document format we've talked about that in the previous part of this tutorial as well you know we can join the data when we write the document right and bring everything together into one structure instead of time and time again having to read all of the different parts of that document from different tables that we would then need to join together right so you join the data on right instead of on read essentially right so all of this means that some of the rules are different and I think what this fundamentally means is that rather than creating a data structure a data model once and for all and then build applications on top of that data model in the nosql world we're actually going to optimize for the access pattern we're optimizing for the queries we're designing the application what are the requirements what are the functional needs of our stakeholders then we're going to say okay that means that we'll have these types of access patterns and these types of queries and then we're going to choose the data model and the database implementation behind it based on those requirements this is the really really fundamental mind shift from application agnostic data models to application specific data models really really important and one of the key Concepts that we use there is what we call embedding right so in query driven data modeling or access pattern based data modeling we're going to be first defining the queries for the application that we have right and then store the data according to the query's needs right so embedding means that what we are going to try to do is to make sure that all the data that we need for a particular transaction for a particular lookup is going to be in the same atomic document One DB access should provide everything you need all the related joined up information that you need for that particular transaction right in that one access right we're going to embed everything into that single Atomic document this is opposed to what we would call referencing right so referencing or joining the data where you leverage the data stored elsewhere using foreign keys and pull it together with that join operation we're going to be embedding a lot more based on this query driven data modeling approach obviously there's a really important considerations to take into account here right when you do this when you do this query driven data modeling you really need to think about some important aspects like you know what is the size of your aggregate what is the size of the document that you're going to be dealing with do you want to limit that in some way or do you want to have that unbounded so to speak thereby also unbounding the transactions and the transaction volumes right so you need to think about that also need to be thinking about the relationships that you want to bring together in a document right so because if you don't and you have a lot of relationships you know let's say that you know a product is related to a to uh to a customer well if lots of customers buy the product and you might have unbounded arrays again you know and this is just something that you want to take into account you don't want these unlimited situations where there's no guard rails no uh no limitations right and therefore estimating the cardinality of relay relationships is really really important right to ask it or not to assets do you need transactionality do you need you know two-phase commits and all those types of things for your particular uh transactions in some of the some of the use cases uh that were at the origin of nosql databases people just decided Well you know I don't care if I lose a transaction right this is obviously not always applicable but you kind of have to think about whether or not it's important yes or no and whether you want to enforce it and what way you're going to be enforcing it because think about it you know if you're embedding right if you're creating document structures that have everything that you need for your transaction in one document you're kind of already implementing some kind of atomic uh transaction right because one document is one Atomic unit right and also never underestimate you know the role of the application the application it's not just a database that has to be adhering to transaction management Concepts right the application has a potential role there as well right and the application might decide okay I need to do some retries or some rollbacks or whatever it is also need to be aware of the impact of indexing we all know this also from the relational World indexing can be very very powerful instrument but if you're not careful you know polymorphic document designs right so these are document designs that can take a lot of different shapes depending on the instance you know you may require a lot of different indexes in order to make this work and too many indexes it's not a free lunch you know you you're going to pay the price for that there's an overhead associated with that so therefore sometimes you might want to design the data a little bit differently and potentially duplicating the data it's not always a bad idea to have duplicate data inside a system then there's the really important topic of schema versioning and schema migration right no database is an island and things will evolve and we're going to be agile and we're going to create new versions of our application and therefore also of the back end behind that application well um some of the beautiful power behind nosql databases will tell you that it's possible to evolve a schema without interruption of the database you know this is different from the rigidity that we used to know in traditional systems where you know any kind of schema change would interrupt the operation and would lead to some kind of downtime well that's no longer the case necessarily right for some operations it will still require some interruptions but you know very often you can just do this on the fly right but of course you know semantically you will still need to worry about whether or not the information that you're storing is going to be usable by all of the different applications or the reporting and the analytical tools that are accessing the same database right so you see whether or not it's possible yes or no is obviously important but whether it's desirable is something completely different and therefore we need to think about transition periods and transition strategies right we don't want to do this we don't want to evolve our [Music] um our Access pattern-based Data models just you know like like it's the wild west then we can do anything there's quite a few different strategies that are used in order to evolve a schema and I would highly recommend the book that is uh on the right of this slide here where uh Pascal DiMare and Daniel kupal and uh Steve hoberman explain in a lot of detail what some of those uh potential strategies might be just from a very high level you know an eager migration strategy would say okay we're first going to migrate the data and then we're going to migrate the application right which you know obviously is still possible but it doesn't necessarily leverage the benefits of our document-based systems for example lazy migration you know basically says you know well we'll just leave it like that and every time someone uses the application we will do the transformation and we will update the documents or the structures that they're using right which means that some documents you know they may never get migrated you know some structures may never get updated and then there's an incremental strategy right which is something that many companies use you know when there's lower load on the system right then we will just have some kind of a backup background process and do some migration of some of the systems you know as we go along you know and so that you know with time everything will get migrated you know as for example we can leverage nighttime load to to to do this work also more and more people are starting to look at heuristics and statistics and estimates to see okay which parts of my data am I going to have to uh migrate beforehand eagerly right which part can I do whenever and which part do I do when I have some time when I have some some lower load for example so this is basically doing this in a data based way you know you're going to leverage some of your uh statistics to do this in the right way so that means that there's combinations of strategies that are possible Right but one thing is for sure I think we do want to make sure that uh our um query driven data models don't have an endless amount of versions at any point in time that's just making life complicated for everyone we also want to think about backward and forward compatibility right no database is an island so that means that many systems could be interacting with this database and that you know you really want to make sure that it's um it stays compatible for as much as it possibly can because any incompatibility you know will impact agility and costs right so we want to think through our Evolution we want to Think Through the features and the schema changes that are going to be happening so that both the consumers and the producers can upgrade at their own pace and then there's a obviously a really important topic which is a very technical Topic in many cases but also has a lot of functional implications which is around the scalability which deals with the scalability of the systems um these nosql databases offer horizontal scaling across you know thousands of different servers by Distributing and sometimes also replicating the data across servers data centers and geographies right this is fantastically powerful obviously but it requires careful design you want to know and think about you know how are you going to distribute the data across your different shards as we call them right so this is usually based on some kind of a predetermined strategy like for example information around a particular country or a continent goes on these servers and a different continent or a different country goes on those servers right so that will mean that you choose a sharding key the country or component in this case depending on the um the application what's sure however is that you want to do this in a way that minimizes the cross-shard communication right you don't want a query that hits more than one Shard because that just introduces lots of lots of overhead inside your data processing capability last but not least data modeling is all about communication and collaboration you know it's all about bringing the technical understanding of a particular um system in line with the business understanding of that system it really is the purpose of all data modeling you don't want the business people to be looking at code right you want to be able to share the the layout and the structure of your application in a graphical format an ERD picture or something like that you know so that they can better understand it and communicate to you about it and collaborate with you around those topics so um this is also why we believe that you know independent of the flexibility and and the power that we find in osql databases and nosql data formats we still need to pay attention to this wonderful profession of data modeling because it really helps both sides to make better systems with some necessary and required uh guard rails so with that we're going to wrap up this part three of our tutorial a recommended reading obviously always available again going to re-emphasize that the mongodb data modeling and schema design book is a fantastic asset not just for mongodb but for many nosql databases out there I highly recommend it and I invite you to follow us on the different socials for more information as well if you have any questions please reach out and with that I'm going to wish you a wonderful day and look forward to seeing you in a next episode of the of this tutorial have a wonderful day bye